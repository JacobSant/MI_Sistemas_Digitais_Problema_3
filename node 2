#include <ESP8266WiFi.h>
#include <ESP8266mDNS.h>
#include <WiFiUdp.h>
#include <ArduinoOTA.h>
#include <PubSubClient.h>
#include <string.h>

String address = "";

//WiFi
const char* SSID = "";                 // SSID / nome da rede WiFi que deseja se conectar
const char* PASSWORD = "";  // Senha da rede WiFi que deseja se conectar
WiFiClient wifiClient;

//MQTT Server
const char* BROKER_MQTT = "broker.emqx.io";  //URL do broker MQTT que se deseja utilizar
int BROKER_PORT = 1883;                      // Porta do Broker MQTT

#define ID_MQTT "TP04/G03"  //Informe um ID unico e seu. Caso sejam usados IDs repetidos a ultima conexão irá sobrepor a anterior.

// Protocolos de requisição 
#define GET_ANALOG_INPUT_VALUE "0x04"
#define GET_DIGITAL_INPUT_VALUE "0x05"
#define SET_ON_NODEMCU_LED "0x06"
#define SET_OFF_NODEMCU_LED "0x07"
#define GET_NODE_CONNECTION_STATUS "0x08"

// Protocolos de resposta
#define NODE_OK "200"
#define LED_OFF "0x03"
#define LED_ON "0x04"

// Definições dos tópicos
#define ANALOG_SENSOR "tp04/g03/node/analog-sensor/value"
#define DIGITAL_SENSOR "tp04/g03/node/digital-sensor/value"
#define REQUEST "tp04/g03/mqtt/request/value"
#define RESPONSE "tp04/g03/mqtt/response/value"
#define ADDRESS "tp04/g03/node/digital-sensor/address"
#define NODE_CONNECTION_STATUS "tp04/g03/node/status"

// Endereços dos sensores digitais
#define SENSOR_D0 "D0"
#define SENSOR_D1 "D1"
#define SENSOR_D2 "D2"
#define SENSOR_D3 "D3"
#define SENSOR_D4 "D4"
#define SENSOR_D5 "D5"
#define SENSOR_D6 "D6"
#define SENSOR_D7 "D7"

PubSubClient MQTT(wifiClient);  // Instancia o Cliente MQTT passando o objeto espClient

//Declaração das Funções
void keepsConnections();  //Garante que as conexoes com WiFi e MQTT Broker se mantenham ativas
void connectWiFi();     //Faz conexão com WiFi
void connectMQTT();     //Faz conexão com Broker MQTT
void receivePackage(char* topic, byte* payload, unsigned int length);

void getDigitalValue(String addr) {
  String value;
  if (addr == "D0") {
    value = String(digitalRead(D0));
    MQTT.publish(DIGITAL_SENSOR, value);
  } else if (addr == "D1") {
    value = String(digitalRead(D1));
    MQTT.publish(DIGITAL_SENSOR, value);
  } else if (addr == "D2") {
    value = String(digitalRead(D2));
    MQTT.publish(DIGITAL_SENSOR, value);
  } else if (addr == "D3") {
    value = String(digitalRead(D3));
    MQTT.publish(DIGITAL_SENSOR, value);
  } else if (addr == "D4") {
    value = String(digitalRead(D4));
    MQTT.publish(DIGITAL_SENSOR, value);
  } else if (addr == "D5") {
    value = String(digitalRead(D5));
    MQTT.publish(DIGITAL_SENSOR, value);
  } else if (addr == "D6") {
    value = String(digitalRead(D6));
    MQTT.publish(DIGITAL_SENSOR, value);
  } else if (addr == "D7") {
    value = String(digitalRead(D7));
    MQTT.publish(DIGITAL_SENSOR, value);
  }
}

void getAnalogValue() {
  String value = String(analogRead(A0));
  MQTT.publish(ANALOG_SENSOR, value);
}

// Configurações para realizar o upload do código via wifi
void OTA_setup(){
  
  Serial.begin(115200);
  Serial.println("Booting");

  // Configuração do IP fixo no roteador, se não conectado, imprime mensagem de falha
  if (!WiFi.config(local_IP, gateway, subnet)) {
    Serial.println("STA Failed to configure");
  }
  WiFi.mode(WIFI_STA);
  WiFi.begin(ssid, password);
  while (WiFi.waitForConnectResult() != WL_CONNECTED) {
    Serial.println("Connection Failed! Rebooting...");
    delay(5000);
    ESP.restart();
  }

  // Port defaults to 8266
  // ArduinoOTA.setPort(8266);

  // Hostname defaults to esp8266-[ChipID]
  ArduinoOTA.setHostname(host);

  // No authentication by default
  // ArduinoOTA.setPassword("admin");

  // Password can be set with it's md5 value as well
  // MD5(admin) = 21232f297a57a5a743894a0e4a801fc3
  // ArduinoOTA.setPasswordHash("21232f297a57a5a743894a0e4a801fc3");

  ArduinoOTA.onStart([]() {
    String type;
    if (ArduinoOTA.getCommand() == U_FLASH) {
      type = "sketch";
    } else { // U_FS
      type = "filesystem";
    }

    // NOTE: if updating FS this would be the place to unmount FS using FS.end()
    Serial.println("Start updating " + type);
  });
  ArduinoOTA.onEnd([]() {
    Serial.println("\nEnd");
  });
  ArduinoOTA.onProgress([](unsigned int progress, unsigned int total) {
    Serial.printf("Progress: %u%%\r", (progress / (total / 100)));
  });
  ArduinoOTA.onError([](ota_error_t error) {
    Serial.printf("Error[%u]: ", error);
    if (error == OTA_AUTH_ERROR) {
      Serial.println("Auth Failed");
    } else if (error == OTA_BEGIN_ERROR) {
      Serial.println("Begin Failed");
    } else if (error == OTA_CONNECT_ERROR) {
      Serial.println("Connect Failed");
    } else if (error == OTA_RECEIVE_ERROR) {
      Serial.println("Receive Failed");
    } else if (error == OTA_END_ERROR) {
      Serial.println("End Failed");
    }
  });
  ArduinoOTA.begin();
  Serial.println("Ready");
  Serial.print("IP address: ");
  Serial.println(WiFi.localIP());  
}

//Faz conexão com WiFi
void connectWifi(){
    if (WiFi.status() == WL_CONNECTED) {
        return;
    }
        
    Serial.print("Conectando-se na rede: ");
    Serial.print(STASSID);
    Serial.println("  Aguarde!");
    WiFi.begin(STASSID, STAPSK); // Conecta na rede WI-FI  
    while (WiFi.status() != WL_CONNECTED) {
        delay(100);
        Serial.print(".");
    }
    
    Serial.println();
    Serial.print("Conectado com sucesso, na rede: ");
    Serial.print(STASSID);  
    Serial.print("  IP obtido: ");
    Serial.println(WiFi.localIP()); 
}


//Garante que as conexoes com WiFi e MQTT Broker se mantenham ativas
void keepsConnections(){
    if (!MQTT.connected()) {
       connectMQTT(); 
    }
    
    connectWiFi(); //se não há conexão com o WiFI, a conexão é refeita
}


void setup() {
  pinMode(LED_BUILTIN, OUTPUT);
  OTA_setup();
  Serial.begin(115200);
  connectWifi();
  MQTT.setServer(BROKER_MQTT, BROKER_PORT);
  MQTT.setCallback(recebePacote);
}

void loop() {
  keepsConnections();
  MQTT.loop();
}

void connectMQTT() {
  while (!MQTT.connected()) {
    Serial.print("Conectando ao Broker MQTT: ");
    Serial.println(BROKER_MQTT);
    if (MQTT.connect(ID_MQTT)) {
      Serial.println("Conectado ao Broker com sucesso!");
      MQTT.subscribe(REQUEST);
      MQTT.subscribe(ADDRESS);
    } else {
      Serial.println("Noo foi possivel se conectar ao broker.");
      Serial.println("Nova tentatica de conexao em 10s");
      delay(10000);
    }
  }
}

void receivePackage(char* topic, byte* payload, unsigned int length) {
  String msg;

  //obtem a string do payload recebido
  for (int i = 0; i < length; i++) {
    char c = (char)payload[i];
    msg += c;
  }

  if (strcmp(topic, REQUEST) == 0) {

    if (msg == SET_ON_NODEMCU_LED) {
      digitalWrite(LED_BUILTIN, LOW);
      MQTT.publish(RESPONSE, LED_ON);
    } else if (msg == SET_OFF_NODEMCU_LED) {
      digitalWrite(LED_BUILTIN, HIGH);
      MQTT.publish(RESPONSE, LED_OFF);
    } else if (msg == GET_NODE_CONNECTION_STATUS) {
      MQTT.publish(NODE_CONNECTION_STATUS,NODE_OK );
    } else if (msg == GET_DIGITAL_INPUT_VALUE) {
      getDigitalValue(address);
    } else if (msg == GET_ANALOG_INPUT_VALUE){
      getAnalogValue();
    }
  } else if (strcmp(topic, ADDRESS) == 0) {
    if (msg.length() == 2) {
      address = msg;
    }
  }

  Serial.print("Mensagem recebida: ");
  Serial.println(msg);
  Serial.println();
}
